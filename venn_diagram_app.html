<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ベン図メーカー</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Webフォントを読み込むための定義 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            /* ページ全体で使うフォントを定義 */
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
        }
        /* 入力欄にフォーカスが当たった時のちょっとしたアニメーション */
        .control-panel input {
            transition: all 0.2s ease-in-out;
        }
        .control-panel input:focus {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(66, 153, 225, 0.5);
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl bg-white rounded-2xl shadow-lg p-6 md:p-8">
        <header class="mb-6 text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">ベン図メーカー</h1>
            <p class="text-gray-600 mt-2">数値を入力すると、下の図にリアルタイムで反映されます。</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8 lg:items-start">
            <!-- コントロールパネル -->
            <div id="control-panel" class="lg-col-span-1 space-y-6 control-panel">
                <div>
                    <div class="flex items-center justify-center space-x-2 mb-4">
                        <button id="two-sets-btn" class="flex-1 py-2 px-4 rounded-lg font-semibold transition bg-blue-500 text-white shadow-md hover:bg-blue-600">2つの集合</button>
                        <button id="three-sets-btn" class="flex-1 py-2 px-4 rounded-lg font-semibold transition bg-gray-200 text-gray-700 hover:bg-gray-300">3つの集合</button>
                    </div>
                </div>

                <!-- 2つの集合用入力 -->
                <div id="two-sets-inputs" class="space-y-3">
                    <div class="grid grid-cols-2 items-center gap-2">
                        <label for="val-a-only" class="font-medium text-gray-700">Aのみ</label>
                        <input type="number" id="val-a-only" value="10" min="0" class="w-full p-2 border rounded-md text-center focus:outline-none focus:ring-2 focus:ring-blue-400">
                    </div>
                    <div class="grid grid-cols-2 items-center gap-2">
                        <label for="val-b-only" class="font-medium text-gray-700">Bのみ</label>
                        <input type="number" id="val-b-only" value="12" min="0" class="w-full p-2 border rounded-md text-center focus:outline-none focus:ring-2 focus:ring-blue-400">
                    </div>
                    <div class="grid grid-cols-2 items-center gap-2">
                        <label for="val-a-and-b" class="font-medium text-gray-700">AとB (A∩B)</label>
                        <input type="number" id="val-a-and-b" value="5" min="0" class="w-full p-2 border rounded-md text-center focus:outline-none focus:ring-2 focus:ring-blue-400">
                    </div>
                    <div class="grid grid-cols-2 items-center gap-2">
                        <label for="val-outside-2" class="font-medium text-gray-700">AでもBでもない</label>
                        <input type="number" id="val-outside-2" value="8" min="0" class="w-full p-2 border rounded-md text-center focus:outline-none focus:ring-2 focus:ring-blue-400">
                    </div>
                </div>

                <!-- 3つの集合用入力 -->
                <div id="three-sets-inputs" class="space-y-3 hidden">
                    <div class="grid grid-cols-2 items-center gap-2">
                        <label for="val-a-only-3" class="font-medium">Aのみ</label>
                        <input type="number" id="val-a-only-3" value="7" min="0" class="w-full p-2 border rounded-md text-center focus:outline-none focus:ring-2 focus:ring-blue-400">
                    </div>
                     <div class="grid grid-cols-2 items-center gap-2">
                        <label for="val-b-only-3" class="font-medium">Bのみ</label>
                        <input type="number" id="val-b-only-3" value="8" min="0" class="w-full p-2 border rounded-md text-center focus:outline-none focus:ring-2 focus:ring-blue-400">
                    </div>
                     <div class="grid grid-cols-2 items-center gap-2">
                        <label for="val-c-only-3" class="font-medium">Cのみ</label>
                        <input type="number" id="val-c-only-3" value="9" min="0" class="w-full p-2 border rounded-md text-center focus:outline-none focus:ring-2 focus:ring-blue-400">
                    </div>
                    <div class="grid grid-cols-2 items-center gap-2">
                        <label for="val-a-b-only" class="font-medium">AとBのみ</label>
                        <input type="number" id="val-a-b-only" value="3" min="0" class="w-full p-2 border rounded-md text-center focus:outline-none focus:ring-2 focus:ring-blue-400">
                    </div>
                     <div class="grid grid-cols-2 items-center gap-2">
                        <label for="val-a-c-only" class="font-medium">AとCのみ</label>
                        <input type="number" id="val-a-c-only" value="4" min="0" class="w-full p-2 border rounded-md text-center focus:outline-none focus:ring-2 focus:ring-blue-400">
                    </div>
                     <div class="grid grid-cols-2 items-center gap-2">
                        <label for="val-b-c-only" class="font-medium">BとCのみ</label>
                        <input type="number" id="val-b-c-only" value="5" min="0" class="w-full p-2 border rounded-md text-center focus:outline-none focus:ring-2 focus:ring-blue-400">
                    </div>
                    <div class="grid grid-cols-2 items-center gap-2">
                        <label for="val-a-b-c" class="font-medium">AとBとC</label>
                        <input type="number" id="val-a-b-c" value="2" min="0" class="w-full p-2 border rounded-md text-center focus:outline-none focus:ring-2 focus:ring-blue-400">
                    </div>
                    <div class="grid grid-cols-2 items-center gap-2">
                        <label for="val-outside-3" class="font-medium">AでもBでもCでもない</label>
                        <input type="number" id="val-outside-3" value="6" min="0" class="w-full p-2 border rounded-md text-center focus:outline-none focus:ring-2 focus:ring-blue-400">
                    </div>
                </div>

                <!-- 計算結果 -->
                <!-- パネルの高さを固定化し、初回描画と入力後のレイアウトずれを防ぐための工夫 -->
                <div id="results-panel" class="pt-6 border-t border-gray-200 space-y-2 text-sm text-gray-700">
                    <h3 class="font-bold text-lg mb-2 text-gray-800">計算結果</h3>
                    <!-- 以下の各行はJSで数値を更新するだけの静的な構造 -->
                    <div id="result-A" class="flex justify-between"><span>A</span><span class="font-semibold"></span></div>
                    <div id="result-B" class="flex justify-between"><span>B</span><span class="font-semibold"></span></div>
                    <div id="result-C" class="flex justify-between"><span>C</span><span class="font-semibold"></span></div>
                    <div id="result-union" class="flex justify-between"><span></span><span class="font-semibold"></span></div>
                    <div id="result-U" class="flex justify-between"><span>全体 (U)</span><span class="font-semibold"></span></div>
                </div>
            </div>

            <!-- ベン図表示エリア -->
            <!-- aspect-square で常に正方形を維持し、レイアウト崩れを防ぐ -->
            <div class="lg:col-span-2 flex items-center justify-center bg-gray-50 rounded-lg aspect-square">
                <canvas id="venn-canvas"></canvas>
            </div>
        </main>
    </div>

    <script>
        // --- グローバル変数定義 ---
        const canvas = document.getElementById('venn-canvas');
        const ctx = canvas.getContext('2d');
        let mode = 'two'; // 'two' or 'three'
        // CSSとCanvasで使うフォントを統一し、描画のずれを防ぐ
        const FONT_FAMILY = "'Inter', 'Noto Sans JP', sans-serif";

        // --- DOM要素の取得 ---
        const inputs = {
            two: {
                a_only: document.getElementById('val-a-only'),
                b_only: document.getElementById('val-b-only'),
                a_and_b: document.getElementById('val-a-and-b'),
                outside: document.getElementById('val-outside-2'),
            },
            three: {
                a_only: document.getElementById('val-a-only-3'),
                b_only: document.getElementById('val-b-only-3'),
                c_only: document.getElementById('val-c-only-3'),
                a_b_only: document.getElementById('val-a-b-only'),
                a_c_only: document.getElementById('val-a-c-only'),
                b_c_only: document.getElementById('val-b-c-only'),
                a_b_c: document.getElementById('val-a-b-c'),
                outside: document.getElementById('val-outside-3'),
            }
        };

        const twoSetsBtn = document.getElementById('two-sets-btn');
        const threeSetsBtn = document.getElementById('three-sets-btn');
        const twoSetsInputs = document.getElementById('two-sets-inputs');
        const threeSetsInputs = document.getElementById('three-sets-inputs');

        // --- 関数定義 ---

        /**
         * 現在のモードに応じて、すべての入力欄から数値を取得する
         * @returns {object} 各領域の数値を格納したオブジェクト
         */
        function getValues() {
            const values = {};
            if (mode === 'two') {
                for (const key in inputs.two) {
                    values[key] = parseInt(inputs.two[key].value, 10) || 0;
                }
            } else {
                 for (const key in inputs.three) {
                    values[key] = parseInt(inputs.three[key].value, 10) || 0;
                }
            }
            return values;
        }

        /**
         * 各集合の合計値や全体集合の値を計算し、結果パネルに表示する
         * @param {object} values - getValues()で取得した数値オブジェクト
         */
        function calculateResults(values) {
            const resA = document.querySelector('#result-A span:last-child');
            const resB = document.querySelector('#result-B span:last-child');
            const resC = document.querySelector('#result-C span:last-child');
            const resUnionLabel = document.querySelector('#result-union span:first-child');
            const resUnionVal = document.querySelector('#result-union span:last-child');
            const resU = document.querySelector('#result-U span:last-child');
            const resCRow = document.getElementById('result-C');

            if (mode === 'two') {
                const a = values.a_only + values.a_and_b;
                const b = values.b_only + values.a_and_b;
                const a_or_b = values.a_only + values.b_only + values.a_and_b;
                const u = a_or_b + values.outside;
                
                resA.textContent = a;
                resB.textContent = b;
                resUnionLabel.innerHTML = 'AまたはB (A&cup;B)';
                resUnionVal.textContent = a_or_b;
                resU.textContent = u;
                // Cの行を非表示にする(レイアウトを崩さないようにvisibilityを使用)
                resCRow.style.visibility = 'hidden';
            } else {
                const a = values.a_only + values.a_b_only + values.a_c_only + values.a_b_c;
                const b = values.b_only + values.a_b_only + values.b_c_only + values.a_b_c;
                const c = values.c_only + values.a_c_only + values.b_c_only + values.a_b_c;
                const a_or_b_or_c = values.a_only + values.b_only + values.c_only + values.a_b_only + values.a_c_only + values.b_c_only + values.a_b_c;
                const u = a_or_b_or_c + values.outside;

                resA.textContent = a;
                resB.textContent = b;
                resC.textContent = c;
                resUnionLabel.innerHTML = 'AまたはBまたはC (A&cup;B&cup;C)';
                resUnionVal.textContent = a_or_b_or_c;
                resU.textContent = u;
                // Cの行を表示する
                resCRow.style.visibility = 'visible';
            }
        }

        /**
         * ベン図を描画するメイン関数
         */
        function draw() {
            // 先に計算と結果表示を行い、レイアウトを確定させる
            const values = getValues();
            calculateResults(values);
            
            // requestAnimationFrameを使い、ブラウザの最適なタイミングで描画する
            requestAnimationFrame(() => {
                const container = canvas.parentElement;
                const size = Math.min(container.clientWidth, container.clientHeight);
                canvas.width = size;
                canvas.height = size;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (size < 20) return; // 小さすぎる場合は描画しない
                
                // --- 描画の基本設定 ---
                const lineWidth = Math.max(1, size * 0.004); 
                const margin = lineWidth * 3;
                const drawRect = {
                    x: margin,
                    y: margin,
                    width: Math.max(0, canvas.width - margin * 2),
                    height: Math.max(0, canvas.height - margin * 2)
                };
                const centerX = drawRect.x + drawRect.width / 2;
                const centerY = drawRect.y + drawRect.height / 2;
                const radius = drawRect.width / 4;

                // --- 全体集合(U)の描画 ---
                ctx.strokeStyle = '#888888';
                ctx.lineWidth = lineWidth;
                ctx.strokeRect(drawRect.x, drawRect.y, drawRect.width, drawRect.height);

                const labelFontSize = Math.max(18, Math.min(radius * 0.4, 36)); 
                ctx.fillStyle = '#333';
                ctx.font = `${labelFontSize}px ${FONT_FAMILY}`;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                const uLabelX = drawRect.x + (labelFontSize * 0.25);
                const uLabelY = drawRect.y + (labelFontSize * 0.25);
                ctx.fillText('U', uLabelX, uLabelY);

                // --- モードに応じて各ベン図を描画 ---
                if (mode === 'two') {
                    drawTwoSetVenn(values, centerX, centerY, radius, labelFontSize);
                } else {
                    drawThreeSetVenn(values, centerX, centerY, radius, labelFontSize, uLabelX, uLabelY);
                }
            });
        }
        
        /**
         * 2つの集合のベン図を描画する
         */
        function drawTwoSetVenn(values, centerX, centerY, radius, labelFontSize) {
            const cy = centerY;
            const shouldDrawA = (values.a_only + values.a_and_b) > 0;
            const shouldDrawB = (values.b_only + values.a_and_b) > 0;

            // --- 入力値に基づき、集合の関係を判定 ---
            const isIdentical = shouldDrawA && shouldDrawB && values.a_only === 0 && values.b_only === 0 && values.a_and_b > 0; // A = B
            const isASubsetOfB = shouldDrawA && shouldDrawB && values.a_only === 0 && values.a_and_b > 0; // A ⊂ B
            const isBSubsetOfA = shouldDrawA && shouldDrawB && values.b_only === 0 && values.a_and_b > 0; // B ⊂ A

            const textFontSize = Math.max(10, Math.min(radius * 0.25, 24));
            
            // --- 集合の関係に応じて、描画方法を分岐 ---

            if (isIdentical) { // ケース1: AとBが等しい (A=B)
                const currentRadius = radius;
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = '#8b5cf6'; // 紫色で表現
                ctx.beginPath();
                ctx.arc(centerX, cy, currentRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.strokeStyle = '#6d28d9';
                ctx.beginPath();
                ctx.arc(centerX, cy, currentRadius, 0, 2 * Math.PI);
                ctx.stroke();

                ctx.fillStyle = '#000';
                ctx.font = `500 ${textFontSize}px ${FONT_FAMILY}`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(values.a_and_b, centerX, cy);
                
                ctx.font = `${labelFontSize}px ${FONT_FAMILY}`;
                ctx.fillStyle = '#6d28d9';
                ctx.fillText('A = B', centerX, cy - currentRadius - (labelFontSize * 0.5));

            } else if (isASubsetOfB) { // ケース2: AがBの部分集合 (A⊂B)
                const outerRadius = radius;
                const innerRadius = radius * 0.5;
                const shift = outerRadius * 0.35; // 内側の円を少しずらす
                const innerCenterX = centerX - shift;
                
                // 外側の円B
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = '#dc2626';
                ctx.beginPath();
                ctx.arc(centerX, cy, outerRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.strokeStyle = '#991b1b';
                ctx.beginPath();
                ctx.arc(centerX, cy, outerRadius, 0, 2 * Math.PI);
                ctx.stroke();

                // 内側の円A
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = '#2563eb';
                ctx.beginPath();
                ctx.arc(innerCenterX, cy, innerRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.strokeStyle = '#1d4ed8';
                ctx.beginPath();
                ctx.arc(innerCenterX, cy, innerRadius, 0, 2 * Math.PI);
                ctx.stroke();
                
                ctx.fillStyle = '#000';
                ctx.font = `500 ${textFontSize}px ${FONT_FAMILY}`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // 数値の位置を調整して重なりを防ぐ
                ctx.fillText(values.b_only, centerX + outerRadius * 0.4, cy);
                ctx.fillText(values.a_and_b, innerCenterX, cy + innerRadius * 0.3);
                
                // ラベルも円の内側と外側に分けて表示
                ctx.font = `${labelFontSize}px ${FONT_FAMILY}`;
                ctx.fillStyle = '#1d4ed8';
                ctx.fillText('A', innerCenterX, cy - innerRadius * 0.4);
                ctx.fillStyle = '#991b1b';
                ctx.fillText('B', centerX + outerRadius * 0.85, cy - outerRadius * 0.85);

            } else if (isBSubsetOfA) { // ケース3: BがAの部分集合 (B⊂A)
                const outerRadius = radius;
                const innerRadius = radius * 0.5;
                const shift = outerRadius * 0.35;
                const innerCenterX = centerX + shift;
                
                // 外側の円A
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = '#2563eb';
                ctx.beginPath();
                ctx.arc(centerX, cy, outerRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.strokeStyle = '#1d4ed8';
                ctx.beginPath();
                ctx.arc(centerX, cy, outerRadius, 0, 2 * Math.PI);
                ctx.stroke();

                // 内側の円B
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = '#dc2626';
                ctx.beginPath();
                ctx.arc(innerCenterX, cy, innerRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.strokeStyle = '#991b1b';
                ctx.beginPath();
                ctx.arc(innerCenterX, cy, innerRadius, 0, 2 * Math.PI);
                ctx.stroke();

                ctx.fillStyle = '#000';
                ctx.font = `500 ${textFontSize}px ${FONT_FAMILY}`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                ctx.fillText(values.a_only, centerX - outerRadius * 0.4, cy);
                ctx.fillText(values.a_and_b, innerCenterX, cy + innerRadius * 0.3);
                
                ctx.font = `${labelFontSize}px ${FONT_FAMILY}`;
                ctx.fillStyle = '#991b1b';
                ctx.fillText('B', innerCenterX, cy - innerRadius * 0.4);
                ctx.fillStyle = '#1d4ed8';
                ctx.fillText('A', centerX - outerRadius * 0.85, cy - outerRadius * 0.85);

            } else { // ケース4: その他の場合 (重なり、離れている、片方のみなど)
                let c1x, c2x, currentRadius;
                if (shouldDrawA && !shouldDrawB) {
                    currentRadius = radius;
                    c1x = centerX;
                } else if (!shouldDrawA && shouldDrawB) {
                    currentRadius = radius;
                    c2x = centerX;
                } else if (shouldDrawA && shouldDrawB) {
                    if (values.a_and_b === 0) { // 共通部分がない場合
                        // 円のサイズを少し小さくし、間隔を空ける
                        currentRadius = radius * 0.8; 
                        const gap = radius * 0.15;
                        c1x = centerX - currentRadius - gap;
                        c2x = centerX + currentRadius + gap;
                    } else { // 共通部分がある場合
                        currentRadius = radius;
                        c1x = centerX - radius / 2;
                        c2x = centerX + radius / 2;
                    }
                }

                if (shouldDrawA) {
                    ctx.globalAlpha = 0.2;
                    ctx.fillStyle = '#2563eb';
                    ctx.beginPath();
                    ctx.arc(c1x, cy, currentRadius, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    ctx.strokeStyle = '#1d4ed8';
                    ctx.beginPath();
                    ctx.arc(c1x, cy, currentRadius, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                
                if (shouldDrawB) {
                    ctx.globalAlpha = 0.2;
                    ctx.fillStyle = '#dc2626';
                    ctx.beginPath();
                    ctx.arc(c2x, cy, currentRadius, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    ctx.strokeStyle = '#991b1b';
                    ctx.beginPath();
                    ctx.arc(c2x, cy, currentRadius, 0, 2 * Math.PI);
                    ctx.stroke();
                }

                ctx.fillStyle = '#000';
                ctx.font = `500 ${textFontSize}px ${FONT_FAMILY}`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                if (shouldDrawA && !shouldDrawB) {
                    ctx.fillText(values.a_only, c1x, cy);
                } else if (!shouldDrawA && shouldDrawB) {
                    ctx.fillText(values.b_only, c2x, cy);
                } else if (shouldDrawA && shouldDrawB) {
                    if (values.a_and_b === 0) {
                        ctx.fillText(values.a_only, c1x, cy);
                        ctx.fillText(values.b_only, c2x, cy);
                    } else {
                        ctx.fillText(values.a_only, c1x - currentRadius / 2, cy);
                        ctx.fillText(values.b_only, c2x + currentRadius / 2, cy);
                        ctx.fillText(values.a_and_b, centerX, cy);
                    }
                }
                
                ctx.font = `${labelFontSize}px ${FONT_FAMILY}`;
                if (shouldDrawA) {
                    ctx.fillStyle = '#1d4ed8';
                    ctx.fillText('A', c1x - currentRadius * 0.85, cy - currentRadius * 0.85);
                }
                if (shouldDrawB) {
                    ctx.fillStyle = '#991b1b';
                    ctx.fillText('B', c2x + currentRadius * 0.85, cy - currentRadius * 0.85);
                }
            }
            
            // どの集合にも属さない数値を円の上部に表示
            ctx.fillStyle = '#000';
            ctx.font = `500 ${textFontSize}px ${FONT_FAMILY}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(values.outside, centerX, centerY - radius * 1.5);
        }

        /**
         * 3つの集合のベン図を描画する
         */
        function drawThreeSetVenn(values, centerX, centerY, radius, labelFontSize, uLabelX, uLabelY) {
            const r = radius * 0.9;
            const textFontSize = Math.max(12, Math.min(r * 0.25, 24));
            const labelFontSize3 = labelFontSize * 0.9;

            // --- 集合が内包される条件を判定 ---
            const isAContained = values.a_only === 0 && (values.a_b_only > 0 || values.a_c_only > 0 || values.a_b_c > 0);
            const isBContained = values.b_only === 0 && (values.a_b_only > 0 || values.b_c_only > 0 || values.a_b_c > 0);
            const isCContained = values.c_only === 0 && (values.a_c_only > 0 || values.b_c_only > 0 || values.a_b_c > 0);
            
            // --- 描画ロジック：包含関係がある場合は特別な描画を行う ---
            if (isAContained) {
                // A ⊂ (B ∪ C) の場合の描画ロジック
                // 外側の2つの円(B, C)を大きくし、少し離して配置
                const r_bc = radius * 1.1;
                const separation = r_bc / 1.8;
                const c_b_x = centerX - separation;
                const c_c_x = centerX + separation;
                const c_bc_y = centerY + r_bc * 0.2;
                // BとCの交点のY座標を幾何学的に計算
                const intersect_y = c_bc_y - Math.sqrt(Math.max(0, r_bc**2 - separation**2));

                // 内包される集合Aを楕円として定義
                const ellipseA = { rx: r * 1.3, ry: r * 0.5 };
                ellipseA.x = centerX;
                // 楕円の上端が、BとCの交点に接するようにY座標を決定
                ellipseA.y = intersect_y + ellipseA.ry;
                
                // --- 図形の塗りつぶし ---
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = '#dc2626'; ctx.beginPath(); ctx.arc(c_b_x, c_bc_y, r_bc, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.arc(c_c_x, c_bc_y, r_bc, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#2563eb'; ctx.beginPath(); ctx.ellipse(ellipseA.x, ellipseA.y, ellipseA.rx, ellipseA.ry, 0, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1.0;

                // --- 図形の枠線 ---
                ctx.strokeStyle = '#991b1b'; ctx.beginPath(); ctx.arc(c_b_x, c_bc_y, r_bc, 0, Math.PI * 2); ctx.stroke();
                ctx.strokeStyle = '#b45309'; ctx.beginPath(); ctx.arc(c_c_x, c_bc_y, r_bc, 0, Math.PI * 2); ctx.stroke();
                ctx.strokeStyle = '#1d4ed8'; ctx.beginPath(); ctx.ellipse(ellipseA.x, ellipseA.y, ellipseA.rx, ellipseA.ry, 0, 0, Math.PI * 2); ctx.stroke();
                
                // --- 数値の描画 ---
                ctx.font = `500 ${textFontSize}px ${FONT_FAMILY}`;
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(values.b_only, c_b_x - r_bc / 2, c_bc_y);
                ctx.fillText(values.c_only, c_c_x + r_bc / 2, c_bc_y);
                ctx.fillText(values.b_c_only, centerX, c_bc_y + r_bc / 2.5);
                ctx.fillText(values.a_b_only, ellipseA.x - ellipseA.rx * 0.65, ellipseA.y);
                ctx.fillText(values.a_c_only, ellipseA.x + ellipseA.rx * 0.65, ellipseA.y);
                ctx.fillText(values.a_b_c, ellipseA.x, ellipseA.y);

                // --- ラベルの描画 ---
                ctx.font = `${labelFontSize3}px ${FONT_FAMILY}`;
                ctx.fillStyle = '#991b1b'; ctx.fillText('B', c_b_x - r_bc * 0.85, c_bc_y - r_bc * 0.85);
                ctx.fillStyle = '#b45309'; ctx.fillText('C', c_c_x + r_bc * 0.85, c_bc_y - r_bc * 0.85);
                ctx.fillStyle = '#1d4ed8'; 
                ctx.textBaseline = 'bottom';
                ctx.fillText('A', ellipseA.x, intersect_y);

            } else if (isBContained) {
                // B ⊂ (A ∪ C) の場合の描画ロジック
                const r_ac = radius * 1.05;
                const c_a_x = centerX - r_ac*0.45;
                const c_a_y = centerY - r_ac*0.45;
                const c_c_x = centerX + r_ac*0.45;
                const c_c_y = centerY + r_ac*0.45;

                ctx.globalAlpha = 0.2;
                ctx.fillStyle = '#2563eb'; ctx.beginPath(); ctx.arc(c_a_x, c_a_y, r_ac, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.arc(c_c_x, c_c_y, r_ac, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.strokeStyle = '#1d4ed8'; ctx.beginPath(); ctx.arc(c_a_x, c_a_y, r_ac, 0, Math.PI * 2); ctx.stroke();
                ctx.strokeStyle = '#b45309'; ctx.beginPath(); ctx.arc(c_c_x, c_c_y, r_ac, 0, Math.PI * 2); ctx.stroke();
                
                // 楕円Bを計算して描画
                const angle = Math.PI / 4;
                const ellipseB = { x: centerX - r*0.25, y: centerY + r*0.25, rx: r*1.2, ry: r*0.5 };
                ctx.save();
                ctx.translate(ellipseB.x, ellipseB.y);
                ctx.rotate(angle);
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = '#dc2626'; ctx.beginPath(); ctx.ellipse(0, 0, ellipseB.rx, ellipseB.ry, 0, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.strokeStyle = '#991b1b'; ctx.beginPath(); ctx.ellipse(0, 0, ellipseB.rx, ellipseB.ry, 0, 0, Math.PI * 2); ctx.stroke();
                ctx.restore();

                // 数値
                ctx.font = `500 ${textFontSize}px ${FONT_FAMILY}`;
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(values.a_only, c_a_x - r_ac/2.5, c_a_y - r_ac/2.5);
                ctx.fillText(values.c_only, c_c_x + r_ac/2.5, c_c_y + r_ac/2.5);
                ctx.fillText(values.a_c_only, centerX + r_ac / 2.5, centerY - r_ac / 2.5);
                ctx.fillText(values.a_b_only, ellipseB.x - r*0.5, ellipseB.y - r*0.5);
                ctx.fillText(values.b_c_only, ellipseB.x + r*0.5, ellipseB.y + r*0.5);
                ctx.fillText(values.a_b_c, ellipseB.x, ellipseB.y);
                
                // ラベル
                ctx.font = `${labelFontSize3}px ${FONT_FAMILY}`;
                ctx.fillStyle = '#1d4ed8'; 
                ctx.textBaseline = 'bottom';
                ctx.fillText('A', c_a_x, c_a_y - r_ac);
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#b45309'; ctx.fillText('C', c_c_x + r_ac * 0.85, c_c_y + r_ac * 0.85);
                ctx.fillStyle = '#991b1b'; ctx.fillText('B', ellipseB.x - r*0.6, ellipseB.y + r*0.6);

            } else if (isCContained) {
                // C ⊂ (A ∪ B) の場合の描画ロジック
                 const r_ab = radius * 1.05;
                 const c_a_x = centerX + r_ab*0.45;
                 const c_a_y = centerY - r_ab*0.45;
                 const c_b_x = centerX - r_ab*0.45;
                 const c_b_y = centerY + r_ab*0.45;
 
                 ctx.globalAlpha = 0.2;
                 ctx.fillStyle = '#2563eb'; ctx.beginPath(); ctx.arc(c_a_x, c_a_y, r_ab, 0, Math.PI * 2); ctx.fill();
                 ctx.fillStyle = '#dc2626'; ctx.beginPath(); ctx.arc(c_b_x, c_b_y, r_ab, 0, Math.PI * 2); ctx.fill();
                 ctx.globalAlpha = 1.0;
                 ctx.strokeStyle = '#1d4ed8'; ctx.beginPath(); ctx.arc(c_a_x, c_a_y, r_ab, 0, Math.PI * 2); ctx.stroke();
                 ctx.strokeStyle = '#991b1b'; ctx.beginPath(); ctx.arc(c_b_x, c_b_y, r_ab, 0, Math.PI * 2); ctx.stroke();
                 
                 // 楕円Cを計算して描画
                 const angle = -Math.PI / 4;
                 const ellipseC = { x: centerX + r*0.25, y: centerY + r*0.25, rx: r*1.2, ry: r*0.5 };
                 ctx.save();
                 ctx.translate(ellipseC.x, ellipseC.y);
                 ctx.rotate(angle);
                 ctx.globalAlpha = 0.2;
                 ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.ellipse(0, 0, ellipseC.rx, ellipseC.ry, 0, 0, Math.PI * 2); ctx.fill();
                 ctx.globalAlpha = 1.0;
                 ctx.strokeStyle = '#b45309'; ctx.beginPath(); ctx.ellipse(0, 0, ellipseC.rx, ellipseC.ry, 0, 0, Math.PI * 2); ctx.stroke();
                 ctx.restore();
 
                // 数値
                ctx.font = `500 ${textFontSize}px ${FONT_FAMILY}`;
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(values.a_only, c_a_x + r_ab / 2.5, c_a_y - r_ab / 2.5);
                ctx.fillText(values.b_only, c_b_x - r_ab/2.5, c_b_y + r_ab/2.5);
                ctx.fillText(values.a_b_only, centerX - r_ab / 2.5, centerY - r_ab / 2.5);
                ctx.fillText(values.a_c_only, ellipseC.x + r*0.5, ellipseC.y - r*0.5);
                ctx.fillText(values.b_c_only, ellipseC.x - r*0.5, ellipseC.y + r*0.5);
                ctx.fillText(values.a_b_c, ellipseC.x, ellipseC.y);
                
                // ラベル
                ctx.font = `${labelFontSize3}px ${FONT_FAMILY}`;
                ctx.fillStyle = '#1d4ed8';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText('A', c_a_x, c_a_y - r_ab);
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#991b1b'; ctx.fillText('B', c_b_x - r_ab * 0.85, c_b_y + r_ab * 0.85);
                ctx.fillStyle = '#b45309'; ctx.fillText('C', ellipseC.x + r*0.6, ellipseC.y + r*0.6);

            } else { // 通常の描画
                const offset = r * 0.5;
                const c1x = centerX;
                const c1y = centerY - offset;
                const c2x = centerX - offset * Math.sqrt(3) / 2 - offset/2;
                const c2y = centerY + offset * 0.9; 
                const c3x = centerX + offset * Math.sqrt(3) / 2 + offset/2;
                const c3y = centerY + offset * 0.9; 

                ctx.globalAlpha = 0.2;
                ctx.fillStyle = '#2563eb'; ctx.beginPath(); ctx.arc(c1x, c1y, r, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#dc2626'; ctx.beginPath(); ctx.arc(c2x, c2y, r, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.arc(c3x, c3y, r, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1.0;
                
                ctx.strokeStyle = '#1d4ed8'; ctx.beginPath(); ctx.arc(c1x, c1y, r, 0, Math.PI * 2); ctx.stroke();
                ctx.strokeStyle = '#991b1b'; ctx.beginPath(); ctx.arc(c2x, c2y, r, 0, Math.PI * 2); ctx.stroke();
                ctx.strokeStyle = '#b45309'; ctx.beginPath(); ctx.arc(c3x, c3y, r, 0, Math.PI * 2); ctx.stroke();

                ctx.font = `500 ${textFontSize}px ${FONT_FAMILY}`;
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                ctx.fillText(values.a_only, c1x, c1y - r/2);
                ctx.fillText(values.b_only, c2x - r/2, c2y + r/2);
                ctx.fillText(values.c_only, c3x + r/2, c3y + r/2);
                ctx.fillText(values.a_b_only, centerX - r*0.55, centerY - r*0.1);
                ctx.fillText(values.a_c_only, centerX + r*0.55, centerY - r*0.1);
                ctx.fillText(values.b_c_only, centerX, centerY + r*0.8);
                ctx.fillText(values.a_b_c, centerX, centerY + r*0.3);
                
                ctx.font = `${labelFontSize3}px ${FONT_FAMILY}`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
    
                ctx.fillStyle = '#1d4ed8'; ctx.fillText('A', c1x, c1y - r * 1.2);
                ctx.fillStyle = '#991b1b'; ctx.fillText('B', c2x - r * 1.15, c2y - r * 0.3);
                ctx.fillStyle = '#b45309'; ctx.fillText('C', c3x + r * 1.15, c3y - r * 0.3);
            }

            // どの集合にも属さない数値をUの右下に配置 (全ケース共通)
            ctx.font = `500 ${textFontSize}px ${FONT_FAMILY}`;
            ctx.fillStyle = '#000';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(values.outside, uLabelX + labelFontSize * 1.6, uLabelY + labelFontSize * 1.2);
        }

        /**
         * 「2つの集合」と「3つの集合」モードを切り替える
         */
        function switchMode(newMode) {
            mode = newMode;
            if (mode === 'two') {
                twoSetsBtn.classList.add('bg-blue-500', 'text-white', 'shadow-md', 'hover:bg-blue-600');
                twoSetsBtn.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-gray-300');
                
                threeSetsBtn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-gray-300');
                threeSetsBtn.classList.remove('bg-blue-500', 'text-white', 'shadow-md', 'hover:bg-blue-600');

                twoSetsInputs.classList.remove('hidden');
                threeSetsInputs.classList.add('hidden');
            } else {
                threeSetsBtn.classList.add('bg-blue-500', 'text-white', 'shadow-md', 'hover:bg-blue-600');
                threeSetsBtn.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-gray-300');

                twoSetsBtn.classList.add('bg-gray-200', 'text-gray-700', 'hover:bg-gray-300');
                twoSetsBtn.classList.remove('bg-blue-500', 'text-white', 'shadow-md', 'hover:bg-blue-600');
                
                threeSetsInputs.classList.remove('hidden');
                twoSetsInputs.classList.add('hidden');
            }
            draw();
        }

        /**
         * 入力値が変更されたときに呼び出され、負の数を0に補正して再描画する
         */
        function handleInput(event) {
            if (parseInt(event.target.value, 10) < 0) {
                event.target.value = '0';
            }
            draw();
        }

        // --- イベントリスナーの設定 ---
        twoSetsBtn.addEventListener('click', () => switchMode('two'));
        threeSetsBtn.addEventListener('click', () => switchMode('three'));

        Object.values(inputs.two).forEach(input => input.addEventListener('input', handleInput));
        Object.values(inputs.three).forEach(input => input.addEventListener('input', handleInput));
        
        window.addEventListener('resize', draw);

        // --- 初期化処理 ---
        // Webフォントの読み込みが完了してから最初の描画を行う
        // これにより、初回描画と入力後のフォントの違いによる表示のずれを完全に防ぐ
        document.fonts.ready.then(() => {
            draw();
        });
    </script>
</body>
</html>
